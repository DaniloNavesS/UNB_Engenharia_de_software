{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"fundamentos_de_SO/classificacoes_SO/","title":"Classifica\u00e7\u00f5es de Sistemas Operacionais","text":""},{"location":"fundamentos_de_SO/classificacoes_SO/#podem-ser-classificados-em-tres-categorias","title":"Podem ser classificados em tr\u00eas categorias","text":"<ul> <li>Sistema Monoprogram\u00e1veis / Monotarefa</li> <li>Sistemas Multiprogram\u00e1veis / Multitarefa</li> <li>Sistemas com M\u00faltiplos Processadores</li> </ul>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistemas-monoprogramaveis","title":"Sistemas Monoprogram\u00e1veis","text":"<ul> <li>Sistemas voltados \u00e0 execu\u00e7\u00e3o de um \u00fanico programa</li> <li>Processadir, mem\u00f3ria, perif\u00e9ricos, permanecem dedicados \u00e0 um \u00fanico programa.</li> </ul> <p>Ex: MS-DOS da Microsoft</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistemas-multiprogramaveis","title":"Sistemas multiprogram\u00e1veis","text":"<ul> <li> <p>Os recursos multiprogram\u00e1veis permitem que os recursos computacionais permitem que os recursos computacionais sejam compartilhados entre os diversos usu\u00e1rios e aplica\u00e7\u00f5es.</p> </li> <li> <p>Enquanto um programa espera um evento, outros podem utilizar o processamento.</p> </li> <li> <p>O sistema operacional \u00e9 respons\u00e1vel por gerenciar acessos concorrentes aos mesmos recursos.</p> </li> <li> <p>Redu\u00e7\u00e3o no tempo de resposta</p> </li> </ul> <p>Ex: Sistema Batch, Sistema de tempo compartilhado, Sistemas de tempo real.</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistema-batch","title":"Sistema Batch","text":"<ul> <li> <p>Inspirados nos cart\u00f5es perfuradados e fitas magn\u00e9ticas.</p> </li> <li> <p>N\u00e3o exige intera\u00e7\u00e3o do usu\u00e1rio com a aplica\u00e7\u00e3o.</p> </li> <li> <p>As aplica\u00e7\u00f5es s\u00e3o organizadas e processadas em lote.</p> </li> </ul>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistemas-de-tempo-compartilhado","title":"Sistemas de tempo compartilhado","text":"<ul> <li> <p>Os sistemas de tempo compartilhado permitem que diferentes programas sejam executados a partir da divis\u00e3o de tempo do processador em pequenas fatias de tempo (time-slice)</p> </li> <li> <p>Diversas mudan\u00e7as s\u00e3o necess\u00e1rias para permitir esse comportamento.</p> </li> </ul> <p>Ex: Windows 98, Linux 2.4</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistema-em-tempo-real","title":"Sistema em tempo real","text":"<ul> <li> <p>Semelhante ao tempo compartilhado, por\u00e9m o tempo real exige a aplica\u00e7\u00f5es r\u00edgidos de limite de tempo a ser cumprido.</p> </li> <li> <p>Subclassificado em tempo real cr\u00edtico: Caso ocorra = grandes preju\u00edzos.</p> </li> </ul> <p>Ex: Controle de tr\u00e1fego a\u00e9reo, controle de ind\u00fastria automobil\u00edstica.</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistemas-com-multiplos-processadores","title":"Sistemas com m\u00faltiplos processadores","text":"<ul> <li> <p>Possuem dois ou mais processadores interligados e trabalhando em conjunto</p> </li> <li> <p>Permite que um programa seja executado mais rapidamente (se o programa for multithreaded)</p> </li> <li> <p>Herdaram v\u00e1rios fundamentos do time-sliced</p> </li> </ul> <p>Ex: Windows XP e posteriores, Linux 2.6 e posteriores</p> <p>Ex de classica\u00e7\u00e3o de m\u00faltiplos processadores: Sistemas operacionais de computadores pessoais, Sistemas operacionais de servidores, Sistemas operacionais embarcados</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#computadores-pessoais","title":"Computadores Pessoais","text":"<ul> <li> <p>Utilizado apenas por um \u00fanico usu\u00e1rio</p> </li> <li> <p>Computadores dom\u00e9sticos</p> </li> </ul> <p>EX: Windows 10, ArchLinux, Debian</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistema-operacionais-de-servidores","title":"Sistema Operacionais de Servidores","text":"<ul> <li> <p>Sistemas cujo objetivo \u00e9 servir o maior n\u00famero de usu\u00e1rios ao mesmo tempo</p> </li> <li> <p>Pode incluir diferentes tipos de servi\u00e7os: servidor web, e-mail, servidor de autentica\u00e7\u00e3o, servidor de backup, etc.</p> </li> </ul> <p>Ex: Ubuntu Server, Cent OS</p>"},{"location":"fundamentos_de_SO/classificacoes_SO/#sistema-operacionais-embarcados","title":"Sistema Operacionais Embarcados","text":"<ul> <li>Sistemas operacionais que funcionam em equipamentos que n\u00e3o aparentam ser um computador: micro-ondas, TV, celulares e smartphones</li> </ul> <p>EX: Android, IOS</p>"},{"location":"fundamentos_de_SO/estrutura_kernel/","title":"Estrutura de Kernel","text":""},{"location":"fundamentos_de_SO/estrutura_kernel/#definicao","title":"Defini\u00e7\u00e3o","text":"<p>\u00c9 de acordo como a estrutura(n\u00facleo) est\u00e1 organizado.</p> <p>Sendo eles, Sistemas Monol\u00edticos, Sistema em camadas, M\u00e1quinas Virtuais, Micro-kernel(cliente/servidor), Exo-kernel.</p>"},{"location":"fundamentos_de_SO/estrutura_kernel/#sistema-monoliticos","title":"Sistema Monol\u00edticos","text":"<ul> <li>O sistema \u00e9 um \"bloco maci\u00e7o\" de c\u00f3digo que opera em modo n\u00facleo, com acesso a todos os recursos do hardware e sem restri\u00e7\u00f5es de acesso a mem\u00f3ria.</li> </ul>"},{"location":"fundamentos_de_SO/estrutura_kernel/#vantagens","title":"Vantagens","text":"<ul> <li>Desempenho: Qualquer componente pode acessar os demais componente diretamente, pois n\u00e3o h\u00e1 barreiras.</li> </ul>"},{"location":"fundamentos_de_SO/estrutura_kernel/#desvantagens","title":"Desvantagens","text":"<ul> <li> <p>Problema de Robustez: Como todos os componentes tem privilegio a todo o hardware, caso ocorra um erro, este erro pode se espalhar rapidamente por todo o sistema.</p> </li> <li> <p>Escabilidade: Como todo o n\u00facleo est\u00e1 unido, o sistema pode ser fortemente interdependentes, tornando a manute\u00e7\u00e3o e a evolu\u00e7\u00e3o mais complexa a cada adi\u00e7\u00e3o de funcionalidades.</p> </li> </ul> <p></p>"},{"location":"fundamentos_de_SO/estrutura_kernel/#sistema-em-camadas","title":"Sistema em camadas","text":"<ul> <li>Uma forma mais elegante de estruturar um sistema operacional faz uso da no\u00e7\u00e3o de camadas: a camada mais baixa realiza a interface com o hardware, enquanto as camadas intermedi\u00e1rias proveem n\u00edveis de abstra\u00e7\u00e3o e ger\u00eancia cada vez mais sofisticados. Por fim, a camada superior define a interface do n\u00facleo para as aplica\u00e7\u00f5es (as chamadas de sistema). As camadas t\u00eam n\u00edveis de privil\u00e9gio decrescentes: a camada inferior tem acesso total ao hardware, enquanto a superior tem acesso bem mais restrito.</li> </ul>"},{"location":"fundamentos_de_SO/estrutura_kernel/#desvantagens_1","title":"Desvantagens","text":"<p>Lento desempenho: Por causa de cada camada precisar se comunicar, acaba deixando lento a comunica\u00e7\u00e3o de por exemplo, entrada do teclado.</p> <p>Divis\u00e3o-n\u00e3o-clara: Como muitos recursos tinha co-rela\u00e7\u00e3o, era dificil separar de maneira \u00f3bvia as camadas</p> <p></p>"},{"location":"fundamentos_de_SO/estrutura_kernel/#micro-kernel","title":"Micro-kernel","text":"<ul> <li> <p>Um micro-kernel visa remover todo c\u00f3digo de alto n\u00edvel do kernel, deixando somente o necess\u00e1rio para interagir com o hardware e criar algumas abstra\u00e7\u00f5es b\u00e1sicas. E o restante do c\u00f3digo ser\u00e1 transferido para programas separados no espa\u00e7o usu\u00e1rio, denominado servi\u00e7os.</p> </li> <li> <p>Os processos interagem com SO atrav\u00e9s de troca de mensagens</p> </li> </ul>"},{"location":"fundamentos_de_SO/estrutura_kernel/#vantagens_1","title":"Vantagens","text":"<p>Modulariza\u00e7\u00e3o: A  abordagem micron\u00facleo oferece maior modularidade, pois cada servi\u00e7o pode ser desenvolvido de forma independente dos demais; mais flexibilidade, pois os servi\u00e7os podem ser carregados e desativados conforme a necessidade; e mais robustez, pois caso um servi\u00e7o falhe, somente ele ser\u00e1 afetado, devido ao confinamento de mem\u00f3ria entre os servi\u00e7os.</p>"},{"location":"fundamentos_de_SO/estrutura_kernel/#desvantagens_2","title":"Desvantagens","text":"<p>Implementa\u00e7\u00e3o: Algumas partes do sistema operacional \u00e9 imposs\u00edvel implementar esse esquema -&gt; carragar comandos nos registradores f\u00edsicos.</p> <p>Dif\u00edcil implementa\u00e7\u00e3o.</p> <p></p>"},{"location":"fundamentos_de_SO/estrutura_kernel/#exo-kernel","title":"Exo-kernel","text":"<ul> <li> <p>o n\u00facleo do sistema apenas proporciona acesso controlado aos recursos do hardware, mas n\u00e3o implementa nenhuma abstra\u00e7\u00e3o.</p> </li> <li> <p>Separado em duas partes: &lt; Exo-kernel -&gt; n\u00facleo minimalista que faz a multiplexa\u00e7\u00e3o segura entre os recursos de hardware, protegendo-os. &lt; LibOS  -&gt; conjunto de biblioteca que gerenciam recursos e oferecem abstra\u00e7\u00f5es de alto n\u00edvel para as aplica\u00e7\u00f5es</p> </li> </ul>"},{"location":"fundamentos_de_SO/visao_geral/","title":"No\u00e7\u00e3o Base de Sistema","text":"<p>Sistema Operacional \u00e9 programa ou conjunto de programas.</p> <ul> <li>Hardware: componentes f\u00edsicos</li> <li>Software: conjunto de todos os programas</li> </ul> <p></p> <p>Tanenbaum: a maioria dos SOs possuem dois modos de opera\u00e7\u00e3o: modo protegido (modo kernel) e modo usu\u00e1rio</p>"},{"location":"fundamentos_de_SO/visao_geral/#definicao-de-sistema-operacional","title":"Defini\u00e7\u00e3o de Sistema Operacional:","text":"<ul> <li> <p>O SO \u00e9 a parte fundamental de software que executa em modo protegido, onde possui acesso a todo hardware e pode executar qualquer instru\u00e7\u00e3o que a m\u00e1quina \u00e9 capaz de executar.</p> </li> <li> <p>Machado &amp; Maia: A grande diferen\u00e7a entre um sistema operacional e aplica\u00e7\u00f5es convecionais \u00e9 a maneira como suas rotinas s\u00e3o executadas.</p> </li> <li> <p>A rotina \u00e9 executado concorrentemente em fun\u00e7\u00e3o de eventos ass\u00edncronos.</p> </li> </ul>"},{"location":"fundamentos_de_SO/visao_geral/#qual-a-funcao-de-um-sistema-operacional","title":"Qual a fun\u00e7\u00e3o de um sistema operacional:","text":"<ul> <li> <p>Um sistema operacional possui duas grandes fun\u00e7\u00f5es: Criar para o usu\u00e1rio uma abstra\u00e7\u00e3o do hardware(m\u00e1quina estendida) e gerenciar os recursos da m\u00e1quina.</p> </li> <li> <p>Alguns dizem que o sistema operacional \u00e9 interface da m\u00e1quina.</p> </li> </ul> <p>OBS: Maquina extendida tem a fun\u00e7\u00e3o de facilitar a vis\u00e3o sobre os recursos da m\u00e1quina e esconder tal complexidade do hardware.</p>"},{"location":"fundamentos_de_SO/visao_geral/#computador","title":"Computador","text":"<ul> <li> <p>O computador \u00e9 um conjunto de recursos que ser\u00e3o compartilhados.</p> </li> <li> <p>O sistema operacional deve proteger esses recursos, especialmente em ambientes com multiplos usu\u00e1rios.</p> </li> </ul>"},{"location":"fundamentos_de_SO/visao_geral/#gerenciador-de-recursos","title":"Gerenciador de Recursos","text":"<p>Exemeplos t\u00edpicos de gerenciamentos</p> <ul> <li> <p>Uso da CPU: um programa s\u00f3 pode sar a CPU durante um periodo determinado pelo escalonador.</p> </li> <li> <p>Uso de Mem\u00f3ria: Um programa deve ser interropido caso use memoria que lhe pertence. (segmentation Fault).</p> </li> <li> <p>Para todo recurso, o SO deve: Manter informa\u00e7\u00f5es sobre o resumo(endere\u00e7o, estados), Decidir quem pode acessar o recurso, Alocar o recurso, etc.</p> </li> <li> <p>E importante que o gerenciamento seja eficiente, maximize a utiliza\u00e7\u00e3o dos recursos e ter um tempo previs\u00edvel de resposta.</p> </li> </ul>"},{"location":"processos/processos/","title":"Processos","text":""},{"location":"processos/processos/#definicao","title":"Defini\u00e7\u00e3o","text":"<ul> <li> <p>Um processo \u00e9 um programa em execu\u00e7\u00e3o acompanhando de valores de tempo de execu\u00e7\u00e3o</p> </li> <li> <p>O processo deve ser visto como uma unidade de contexto, ou seja, um cont\u00eainer de recursos utilizados por uma ou mais tarefas para sua execu\u00e7\u00e3o: \u00e1reas de mem\u00f3ria (c\u00f3digo, dados, pilha), informa\u00e7\u00f5es de contexto e descritores de recursos do n\u00facleo (arquivos abertos, conex\u00f5es de rede, etc).</p> </li> </ul> <p></p>"},{"location":"processos/processos/#elementos-de-um-processo","title":"Elementos de um processo","text":"<ul> <li>C\u00f3digo execut\u00e1vel</li> <li>Pilha de execu\u00e7\u00e3o: contendo valores de vari\u00e1veis locais</li> <li>Apontador para pilha: registrador da CPU que armazena em qual \u00e1rea de mem\u00f3ria est\u00e1 a pilha</li> <li>Contador de programa: registrador da CPU que armazena a pr\u00f3xima instru\u00e7\u00e3o a ser executada</li> <li>Valores dos registradores gerais da m\u00e1quina</li> </ul>"},{"location":"processos/processos/#classificacao-dos-modelos","title":"Classifica\u00e7\u00e3o dos modelos","text":"<ul> <li> <p>Processos quanto ao custo de troca de contexto e de manuten\u00e7\u00e3o</p> </li> <li> <p>Heavyweight(Processo tradicional)</p> </li> <li>Lightweight(threads)</li> </ul>"},{"location":"processos/processos/#heavyweight","title":"Heavyweight","text":"<ul> <li>O processo \u00e9 composto tanto pelo ambiente como pela a execu\u00e7\u00e3o</li> </ul> <p>Os processos s\u00e3o criados:</p> <ul> <li>In\u00edcio do sistema</li> <li>Execu\u00e7\u00e3o de uma chamada ao sistema de cria\u00e7\u00e3o de processo por um processo em execu\u00e7\u00e3o</li> <li>Requisi\u00e7\u00e3o do usu\u00e1rio</li> <li>In\u00edcio de um job de lote</li> </ul>"},{"location":"processos/processos/#inicializar-do-so","title":"Inicializar do SO","text":"<ul> <li> <p>Alguns executam em primeiro plano e interagem com usu\u00e1rios</p> </li> <li> <p>Outros executam em segundo plano: chamados de daemons</p> </li> </ul> <p>Daemons: \u00e9 um processo em segundo plano que executa tarefas espec\u00edficas de forma aut\u00f4noma e cont\u00ednua, sem a necessidade de intera\u00e7\u00e3o direta com o usu\u00e1rio.</p> <ul> <li>Geralmente os processos s\u00e3o criados por outro</li> </ul> <p>Hierarquia em \u00e1rvore:</p> <p></p>"},{"location":"processos/processos/#criacao-de-processo-no-unix","title":"Cria\u00e7\u00e3o de processo no Unix","text":"<pre><code>fork();\n</code></pre> <ul> <li>Clone id\u00eantico ao processo que chamou</li> <li>Normalmente, executa execve depois da chamada para mudar o \"programa\" em execu\u00e7\u00e3o</li> </ul>"},{"location":"processos/processos/#condicoes-de-termino-de-processos","title":"Condi\u00e7\u00f5es de t\u00e9rmino de processos:","text":"<ul> <li>Sa\u00edda normal (volunt\u00e1ria)</li> <li>Sa\u00edda por erro (volunt\u00e1ria)</li> <li>Erro fatal (involunt\u00e1rio)</li> <li>Cancelamento por outro processo (involunt\u00e1rio)</li> </ul>"},{"location":"processos/processos/#hierarquia-de-processos","title":"Hierarquia de processos","text":"<ul> <li>Quando um processo \u00e9 criado por outro, eles continuam assoaciados.</li> <li>Em alguns sistemas, \u00e9 possivel listar o ppid (parent pid)</li> <li>Todos os processos s\u00e3o filhos ou descendentes dos processos init.</li> </ul>"},{"location":"processos/processos/#estados-dos-processos","title":"Estados dos processos","text":"<p>Estados de um processo: Rodando, Bloqueado, Pronto</p> <ul> <li>Quando o processo est\u00e1 esperando um evento, dizemos que ele est\u00e1 bloqueado:</li> </ul> <p>Leitura em disco -&gt; Leitura de rede -&gt; Esperando entrada de usu\u00e1rio</p> <p>Representa\u00e7\u00e3o de estados de um processo</p> <p></p> <p>(1) O processo bloqueia-se aguardando uma entrada</p> <p>(2) O evento aguardado pelo processo ocorreu, pode-se iniciar a executar.</p> <p>(3) O tempo de posse do processador esgotou-se</p> <p>(4) O processo \u00e9 escolhido pelo escalonador para executar</p>"},{"location":"processos/processos/#cpu-bound-e-io-bound","title":"CPU Bound e I/O Bound","text":"<ul> <li> <p>CPU Bound: s\u00e3o tarefas que usam intensivamente o processador na maior parte de sua exist\u00eancia. Essas tarefas passam a maior parte do tempo nos estados pronta ou executando.</p> </li> <li> <p>I/O Bound: S\u00e3o tarefas que dependem muito mais dos dispositivos de entrada/sa\u00edda que do processador. Essas tarefas ficam boa parte de suas exist\u00eancias no estado suspenso, aguardando respostas \u00e0s suas solicita\u00e7\u00f5es de leitura e/ou escrita de dados nos dispositivos de entrada/sa\u00edda.</p> </li> </ul>"},{"location":"processos/processos/#implementacao-de-processos","title":"Implementa\u00e7\u00e3o de processos","text":""},{"location":"processos/processos/#troca-de-contexto","title":"Troca de contexto:","text":"<ul> <li> <p>Opera\u00e7\u00e3o de salvamento dos registradores de um processo e posterior restaura\u00e7\u00e3o de registradores de outro processo.</p> </li> <li> <p>A troca de contexto permite a troca de processador entre os processos</p> </li> <li> <p>Cada dispositivo de E/S possui possui uma \u00e1rea de mem\u00f3ria chamada vetor de interrup\u00e7\u00f5es</p> </li> </ul>"},{"location":"processos/processos/#diagrama-temporal","title":"Diagrama temporal","text":"<p>Principais passos envolvidos em uma troca de contexto:</p> <ol> <li>Uma tarefa A est\u00e1 executando;</li> <li>Ocorre uma interrup\u00e7\u00e3o do temporizador do hardware e a execu\u00e7\u00e3o desvia para a rotina de tratamento, no n\u00facleo;</li> <li>A rotina de tratamento ativa o despachante;</li> <li>O despachante salva o estado da tarefa A em seu TCB e atualiza suas informa\u00e7\u00f5es de ger\u00eancia;</li> <li>Opcionalmente, o despachante consulta o escalonador para escolher a pr\u00f3xima tarefa a ativar (B);</li> <li>O despachante resgata o estado da tarefa B de seu TCB e a reativa.</li> </ol> <p></p>"},{"location":"processos/processos/#escalonador-de-processos","title":"Escalonador de Processos","text":"<ul> <li> <p>O Sistema Operacional \u00e9 respons\u00e1vel por gerenciar o(s) recurso(s) de processamento de um computador por meio de sua atividade chamada Escalonador de Processador</p> </li> <li> <p>Os escalonadores podem ser classificados como Preemptivos ou Cooperativo(N\u00e3o-Preemptivos).</p> </li> </ul> <p>A preemp\u00e7\u00e3o \u00e9 a suspens\u00e3o tempor\u00e1ria da execu\u00e7\u00e3o de um processo.</p>"},{"location":"processos/processos/#sistemas-preemptivos","title":"Sistemas preemptivos:","text":"<ul> <li> <p>Nestes sistemas uma tarefa pode perder o processador caso termine seu quantum de tempo, caso execute uma chamada de sistema ou caso ocorra uma interrup\u00e7\u00e3o que acorde uma tarefa mais priorit\u00e1ria (que estava suspensa aguardando um evento). A cada interrup\u00e7\u00e3o, exce\u00e7\u00e3o ou chamada de sistema, o escalonador reavalia todas as tarefas da fila de prontas e decide se mant\u00e9m ou substitui a tarefa atualmente em execu\u00e7\u00e3o.</p> </li> <li> <p>Cada Processo tem seu tempo(time-slice) de posse do processador</p> </li> <li> <p>O controle de tempo de execu\u00e7\u00e3o \u00e9 feito por interrup\u00e7\u00e3o</p> </li> </ul>"},{"location":"processos/processos/#sistemas-cooperativos","title":"Sistemas cooperativos:","text":"<ul> <li> <p>A tarefa em execu\u00e7\u00e3o permanece no processador tanto quanto poss\u00edvel, s\u00f3 liberando o mesmo caso termine de executar, solicite uma opera\u00e7\u00e3o de entrada/sa\u00edda ou libere explicitamente o processador1, voltando \u00e0 fila de tarefas prontas. Esses sistemas s\u00e3o chamados de cooperativos por exigir a coopera\u00e7\u00e3o das tarefas entre si na gest\u00e3o do processador, para que todas possam executar.</p> </li> <li> <p>Nenhuma entidade externa \u201ctira a CPU \u00e0 for\u00e7a\u201d do processo</p> </li> </ul>"},{"location":"processos/processos/#criterios-do-escalonador","title":"Crit\u00e9rios do Escalonador","text":"<ul> <li> <p>Justi\u00e7a: garantir que todos os processos ter\u00e3o chances justas de uso de processador.</p> </li> <li> <p>Efici\u00eancia: quando existir trabalho a fazer, o processador deve estar ocupado.</p> </li> <li> <p>Minimizar o tempo de resposta: reduzindo o tempo dos usu\u00e1rios interativos, reduz o tempo entre a entrada de usu\u00e1rio e a resposta dada (n\u00e3o considera tempo total de execu\u00e7\u00e3o).</p> </li> <li> <p>Minimizar o turnaround: reduzir o tempo desde o lan\u00e7amento do processo at\u00e9 seu t\u00e9rmino. Soma de: tempo de espera por recursos (mem\u00f3ria, processador, E/S) e tempo de utiliza\u00e7\u00e3o da CPU. Mais utilizado em processamento batch.</p> </li> <li> <p>Minimizar waiting time: Esse crit\u00e9rio visa minimizar o tempo de espera pela CPU</p> </li> <li> <p>Maximizar throughtput: Maximizar o n\u00famero de tarefas executados em uma unidade de tempo</p> </li> </ul>"},{"location":"processos/processos/#algoritimos-classicos-de-escalonamento","title":"Algoritimos cl\u00e1ssicos de escalonamento","text":"<p>Sendo eles: First Come First Served, Round-Robin, Prioridades, Shorteste Job First</p>"},{"location":"processos/processos/#first-come-first-servedfcfs","title":"First Come First Served(FCFS)","text":"<ul> <li>O processo obt\u00e9m a CPU de acordo com a ordem da chegada das solicita\u00e7\u00f5es. o processo que pede a CPU primeiro, obt\u00e9m a CPU em primeiro lugar</li> </ul> <ul> <li> <p>O escalonador FCFS \u00e9 N\u00e3o-preemptivo</p> </li> <li> <p>Um processo CPU/bound pode fazer com que v\u00e1rios processos esperem por um tempo indeterminado.</p> </li> </ul>"},{"location":"processos/processos/#vantagens","title":"Vantagens","text":"<ul> <li>Simples de ser implementado</li> <li>Algoritmo efieciente: CPU sempre \u00e9 utilizada</li> </ul>"},{"location":"processos/processos/#desvantagens","title":"Desvantagens","text":"<ul> <li>Impossibilidade de se prever quando um processo vai iniciar</li> <li>Tempo de espera n\u00e3o \u00e9 priorizado</li> </ul>"},{"location":"processos/processos/#round-robin","title":"Round-Robin","text":"<ul> <li>Cada processo tem o direito de usar o processador por um intervalo de tempo pr\u00e9-definido. Este intervalo de tempo \u00e9 denominado quantum</li> </ul> <ul> <li>Algoritmo por altern\u00e2ncia circular</li> </ul> <ul> <li> <p>Algoritmo justo</p> </li> <li> <p>Dificuldade de determinar bom quantum para ser atribu\u00eddo;</p> </li> <li> <p>Sendo assim, Quantum muito longo: FCFS e Quantum muito curto: perda de v\u00e1rios requisitos, tais como efici\u00eancia.</p> </li> <li> <p>Para o algoritmo ser eficiente \u00e9 necess\u00e1rio que o tempo de troca de contexto seja consideravelmente menor que a execu\u00e7\u00e3o do programa</p> </li> </ul>"},{"location":"processos/processos/#escalonamento-com-prioridades","title":"Escalonamento com prioridades","text":"<ul> <li> <p>Cada processo \u00e9 atribu\u00edda uma prioridade. Processos com prioridade maior rodam primeiro</p> </li> <li> <p>Prioridades podem ser atribu\u00eddas de duas formas: est\u00e1tica ou din\u00e2mica</p> </li> </ul>"},{"location":"processos/processos/#estatica","title":"Est\u00e1tica","text":"<ul> <li>Os processos s\u00e3o divididos em classes e a cada classe \u00e9 atribu\u00edda uma prioridade. A cada prioridade existe uma fila de prontos associada</li> </ul>"},{"location":"processos/processos/#dinamica","title":"Din\u00e2mica","text":"<ul> <li> <p>O sistema analisa o comportamento dos processos e atribui prioridades favorecendo um certo tipo de comportamento</p> </li> <li> <p>Processos I/O devem possuir prioridade alta</p> </li> <li>Prioridade din\u00e2mica: 1/f, onde f \u00e9 a fra\u00e7\u00e3o do quantum de tempo usada na \u00faltima rodada do processo</li> </ul>"},{"location":"processos/processos/#shortest-job-first","title":"Shortest Job First","text":"<ul> <li>Dado um conjunto de processos, execute os de menor tempo de execu\u00e7\u00e3o antes.</li> </ul>"},{"location":"processos/processos/#vantagens_1","title":"Vantagens","text":"<ul> <li>Projetado para sistemas em lotes</li> <li>Diminui o tempo de turnaround(tempo de lan\u00e7amento do processo at\u00e9 seu t\u00e9rmino)</li> </ul>"},{"location":"processos/processos/#desvatagens","title":"Desvatagens","text":"<ul> <li>Requer que o tempo total de execu\u00e7\u00e3o do processo seja conhecido antes do seu in\u00edcio</li> </ul>"},{"location":"processos/processos/#threads","title":"Threads","text":""},{"location":"processos/processos/#definicao_1","title":"Defini\u00e7\u00e3o:","text":"<ul> <li> <p>Uma thread \u00e9 definida como sendo um fluxo de execu\u00e7\u00e3o independente. Um processo pode conter uma ou mais threads, cada uma executando seu pr\u00f3prio c\u00f3digo e compartilhando recursos com as demais threads localizadas no mesmo processo.</p> </li> <li> <p>Permitem que m\u00faltiplas execu\u00e7\u00f5es ocorram no mesmo ambiente.</p> </li> </ul> <p></p> <p>Na figura, o processo A tem v\u00e1rias threads, enquanto o processo B \u00e9 sequencial (tem uma \u00fanica thread).</p> <ul> <li> <p>No modelo multithread, a entidade processo \u00e9 dividida em processo e thread.</p> </li> <li> <p>O processo corresponde ao ambiente</p> </li> <li> <p>Thread corresponde ao estado da execu\u00e7\u00e3o</p> </li> <li> <p>Um processo \u00e9 composto por v\u00e1rias threads que compartilham o ambiente: mem\u00f3ria, descritor de arquivos, entre outros.</p> </li> <li> <p>Threads compartilham as mesmas vari\u00e1veis globais</p> </li> <li> <p>A prote\u00e7\u00e3o dos recursos entre threads \u00e9 responsabilidade do programador</p> </li> <li> <p>S\u00e3o necess\u00e1rios mecanismos de sincroniza\u00e7\u00e3o</p> </li> <li> <p>A pilha \u00e9 uma estrutura em mem\u00f3ria, por\u00e9m cada thread possui a sua pr\u00f3pria pilha e n\u00e3o compartilha esses dados com as outras threads</p> </li> <li> <p>Threads s\u00e3o mais f\u00e1ceis de criar e destruir do que processos, afinal apenas \u00e1rea de execu\u00e7\u00e3o precisa ser alocada</p> </li> </ul>"},{"location":"processos/processos/#implementacao-de-threads","title":"Implementa\u00e7\u00e3o de Threads","text":""},{"location":"processos/processos/#implementar-em-nivel-de-so","title":"Implementar em n\u00edvel de SO","text":"<ul> <li> <p>O SO deve se tornar respons\u00e1vel por isso</p> </li> <li> <p>Criar abstra\u00e7\u00f5es de processos e de threads</p> </li> <li> <p>Implementar o modelo de processos heavyweight e simular m\u00faltiplas threads atrav\u00e9s de bibliotecas</p> </li> <li> <p>Mais vi\u00e1vel em SO com kernel n\u00e3o-monol\u00edtico</p> </li> <li> <p>O kernal deve criar as threads, organizar seu escalonador e t\u00e9rmino</p> </li> <li> <p>Exist\u00eancia de uma tabela de threads no kernel, que cont\u00e9m os dados de cada thread</p> </li> <li> <p>Quando uma thread \u00e9 bloqueada, o kernel \u00e9 respons\u00e1vel por escalonar outra thread para rodar, mesmo que seja de outro processo.</p> </li> </ul> <p></p>"},{"location":"processos/processos/#implementacao-em-nivel-usuario","title":"Implementa\u00e7\u00e3o em n\u00edvel usu\u00e1rio","text":"<ul> <li> <p>As threads s\u00e3o simuladas no processo de usu\u00e1rio</p> </li> <li> <p>Cada processo precisa de sua pr\u00f3pria tabela de threads</p> </li> <li> <p>Threads manipuladas por fun\u00e7\u00f5es</p> </li> <li> <p>Geralmente, o escalonador do SO \u00e9 n\u00e3o-preemptivo</p> </li> <li> <p>Quando uma thread for perder o controle, ela chama um procedimento do ambiente de execu\u00e7\u00e3o para selecionar outra thread para executar</p> </li> <li> <p>Troca de contexto muito r\u00e1pida entre as threads</p> </li> <li> <p>Cada processo pode ter seu pr\u00f3prio algoritmo de escalonamento. Muitas vezes, o tipo de algoritmo de escalonamento \u00e9 melhor para certos problemas.</p> </li> <li> <p>Se a chamada realmente for bloquear, ela s\u00f3 \u00e9 realizado caso n\u00e3o exista thread para executar</p> </li> </ul> <p></p> <p>Compara\u00e7\u00e3o entre Threads em n\u00edvel usu\u00e1rio e n\u00edvel SO</p> <p></p>"},{"location":"processos/processos/#implementacao-em-modo-hibrido","title":"Implementa\u00e7\u00e3o em modo h\u00edbrido","text":"<ul> <li> <p>As arquiteturas de threads no modo h\u00edbrido busca combinar as vantagens das threads em modo usu\u00e1rio e threads em modo kernel.</p> </li> <li> <p>Um processo pode ter v\u00e1rias threads de kernel.</p> </li> <li> <p>Por sua vez, cada thread kernel pode conter diversas threads em modo usu\u00e1rio.</p> </li> </ul> <p></p> <ul> <li> <p>Pacote POSIX threads(pthreads) Biblioteca amplamente utilizada para suportar threads.</p> </li> <li> <p>Inclui mecanismo de controle e sincroniza\u00e7\u00e3o</p> </li> </ul>"},{"location":"processos/processos/#modelo-de-execucao-de-threads","title":"Modelo de execu\u00e7\u00e3o de threads","text":"<ul> <li> <p>Threads din\u00e2micas: onde uma thread \u00e9 criada para tratar cada requisi\u00e7\u00e3o</p> </li> <li> <p>Thread est\u00e1tica: o n\u00famero de threads \u00e9 fixo</p> </li> </ul>"},{"location":"processos/processos/#modelo-despachante-dispatcher","title":"Modelo despachante (Dispatcher)","text":"<ul> <li> <p>Respons\u00e1vel por receber o trabalho, mas n\u00e3o o processa.</p> </li> <li> <p>O despachante seleciona uma thread trabalhadora para entregar o trabalho</p> </li> <li> <p>A thread trabalhadora executa a solicita\u00e7\u00e3o e sinaliza o dispatcher</p> </li> </ul> <p></p> <p>Ex: Servidor Web</p> <ol> <li> <p>Um servidor web recebe v\u00e1rias requisi\u00e7\u00f5es de diversos clientes.</p> </li> <li> <p>As requisi\u00e7\u00f5es podem envolver leitura de disco</p> </li> <li> <p>Se a mesma thread \u00e9 respons\u00e1vel por receber uma nova requisi\u00e7\u00e3o e ler o disco, pode-se ter um problema. Especialmente se o equipamento de rede for mais r\u00e1pido que o disco</p> </li> </ol>"},{"location":"processos/processos/#vantagens_2","title":"Vantagens:","text":"<ul> <li> <p>Consumo r\u00e1pido de mensagens</p> </li> <li> <p>Boa distribui\u00e7\u00e3o de requisi\u00e7\u00f5es</p> </li> <li> <p>Flexibilidade: podemos facilmente mudar os n\u00fameros de threads</p> </li> </ul>"},{"location":"processos/processos/#desvantagens_1","title":"Desvantagens","text":"<ul> <li>Pouco uso de CPU pela thread despachante, Em alguns benchmarks pode considerar apenas 80% do uso total da CPU.</li> </ul>"},{"location":"processos/processos/#modelo-time","title":"Modelo Time","text":"<ul> <li>As threads s\u00e3o aut\u00f4mas e gulosas por servi\u00e7os. Elas acessam um \"poll\" de tarefa, obtem e as executam.</li> </ul>"},{"location":"processos/processos/#vantagens_3","title":"Vantagens","text":"<ul> <li> <p>Bom consumo de mensagens</p> </li> <li> <p>Boa distribui\u00e7\u00e3o de requisi\u00e7\u00f5es</p> </li> <li> <p>Flexibilidade em mudar o n\u00famero de tarefas</p> </li> </ul>"},{"location":"processos/processos/#desvantagens_2","title":"Desvantagens","text":"<ul> <li>Cuidado na implementa\u00e7\u00e3o. Em computadores modernos, uma thread inicia o programa e deve ser respons\u00e1vel por criar todas as outras. Ap\u00f3s isso, ela deve se tornar uma thread normal do time.</li> </ul>"},{"location":"processos/processos/#modelo-pipeline","title":"Modelo Pipeline","text":"<ul> <li>Cada thread realiza uma tarefa espec\u00edfica produzindo dados de entrada de outra thread. Os dados de sa\u00edda final s\u00e3o produzidos pela \u00faltima thread</li> </ul>"},{"location":"processos/processos/#desvantagem","title":"Desvantagem","text":"<ul> <li> <p>Se uma thread for muito mais lenta que as outras, todo o processamento \u00e9 desperdi\u00e7ado.</p> </li> <li> <p>Muitas vezes n\u00e3o e f\u00e1cil dividir a tarefa em um pipeline.</p> </li> </ul>"},{"location":"processos/processos/#condicao-de-corrida","title":"Condi\u00e7\u00e3o de corrida","text":"<p>Considere os seguinte Processos/Thread incrementando uma vari\u00e1vel em mem\u00f3ria compartilhada</p> <p></p> <p>Considere, x = 0</p> <p>Assumindo que X est\u00e1 na posi\u00e7\u00e3o de mem\u00f3ria 0x2000</p> <p>Escalonador: A -&gt; B</p> <p></p> <p>Escalonador: A -&gt; B -&gt; A</p> <p></p>"},{"location":"processos/processos/#exclusao-mutual","title":"Exclus\u00e3o Mutual","text":"<ul> <li>\u00c9 um mecanismo de sincroniza\u00e7\u00e3o em programa\u00e7\u00e3o concorrente que garante que apenas um processo ou thread possa acessar uma se\u00e7\u00e3o cr\u00edtica de c\u00f3digo por vez.</li> </ul>"},{"location":"processos/processos/#variavel-de-impedimento","title":"Vari\u00e1vel de impedimento","text":"<ul> <li>Vari\u00e1vel de impedimento busca marcar se existe algu\u00e9m na se\u00e7\u00e3o cr\u00edtica. Se for 1, n\u00e3o procede</li> </ul> <pre><code>int thread() {\n    while(true) {\n        while (busy == 1) {}\n        busy = 1;\n        regiao_critica();\n        busy = 0;\n    }\n}\n</code></pre> <ul> <li>Se ocorrer uma troca de contexto depois de sair do loop e antes do processo/thread trocar o valor para 1, h\u00e1 uma condi\u00e7\u00e3o de corrida.</li> </ul>"},{"location":"processos/processos/#para-uma-boa-exclusao-mutual","title":"Para uma boa exclus\u00e3o mutual","text":"<ul> <li> <p>Somente um processo pode estar nas regi\u00f5es cr\u00edticas</p> </li> <li> <p>Nada pode ser afirmado sobre a velocidade ou sobre o n\u00famero de CPUs</p> </li> <li> <p>Nenhum processo executando fora de sua regi\u00e3o cr\u00edtica pode bloquear outros processos</p> </li> <li> <p>Nenhum processo deve esperar eternamente para entrar em sua regi\u00e3o cr\u00edtica.</p> </li> </ul>"},{"location":"processos/processos/#tecnicas-para-implementacao-de-exclusao-mutual","title":"T\u00e9cnicas para implementa\u00e7\u00e3o de exclus\u00e3o m\u00fatual","text":"<p>Inibir interrup\u00e7\u00f5es</p> <p>Com espera ocupada:</p> <ul> <li>Estrita Altern\u00e2ncia</li> <li>Algoritmo de Peterson</li> <li>Utilizar hardware adicional</li> </ul> <p>Com bloqueio de processos:</p> <ul> <li>Sem\u00e1foros</li> <li>Mutexes</li> <li>Locks</li> <li>Monitores</li> <li>Vari\u00e1veis de condi\u00e7\u00e3o</li> </ul>"},{"location":"processos/processos/#inibir-interrupcoes","title":"Inibir interrup\u00e7\u00f5es","text":"<ol> <li> <p>Desativar interrup\u00e7\u00f5es: Antes de entrar na se\u00e7\u00e3o cr\u00edtica, a thread desativa as interrup\u00e7\u00f5es do processador. Isso impede que outras threads interrompam a execu\u00e7\u00e3o da se\u00e7\u00e3o cr\u00edtica.</p> </li> <li> <p>Executar a se\u00e7\u00e3o cr\u00edtica: Com as interrup\u00e7\u00f5es desativadas, a thread executa o c\u00f3digo da se\u00e7\u00e3o cr\u00edtica sem a interfer\u00eancia de outras threads. Isso garante que os dados compartilhados sejam acessados e modificados de forma consistente.</p> </li> <li> <p>Reativar interrup\u00e7\u00f5es: Ao finalizar a se\u00e7\u00e3o cr\u00edtica, a thread reativa as interrup\u00e7\u00f5es do processador, permitindo que outras threads retomem a execu\u00e7\u00e3o normal.</p> </li> <li> <p>Fun\u00e7\u00e3o aplamente utilizada apenas em modo kernel, o programador no espa\u00e7o usu\u00e1rio n\u00e3o tem acesso \u00e0 essa chamada.</p> </li> </ol>"},{"location":"processos/processos/#espera-ocupadabusy-waiting","title":"Espera ocupada/Busy waiting","text":"<pre><code>while (vez != minha) { };\n</code></pre> <ul> <li> <p>Desperdi\u00e7a o tempo que possui CPU fazendo um teste trivial.</p> </li> <li> <p>A espera ocupada desperdi\u00e7a o tempo que possui CPU fazendo um teste trivial</p> </li> <li> <p>Deve ser utilizada quando h\u00e1 uma expectativa de esperar pouco/muito pouco.</p> </li> <li> <p>Algumas vezes obrigat\u00f3ria em modo kernel.</p> </li> </ul>"},{"location":"processos/processos/#estrita-alternancia","title":"Estrita altern\u00e2ncia","text":"<ul> <li> <p>Estrita altern\u00e2ncia resolve o problema da exclus\u00e3o m\u00fatua para dois processos.</p> </li> <li> <p>A ideia \u00e9 que um processo marque que est\u00e1 na se\u00e7\u00e3o cr\u00edtica.</p> </li> <li> <p>Outro processo aguarda a sa\u00edda.</p> </li> </ul> <pre><code>int turn = 0 // var global\n\nint thread_A() {\n    while(true) {\n        while(turn != 1);\n        regi\u00e3o_critica();\n        turn = 0;\n        regiao_nao_critica();\n    }\n}\n\nint thread_B() {\n    while(true) {\n        while(turn != 0);\n        regi\u00e3o_critica();\n        turn = 1;\n        regiao_nao_critica();\n    }\n}\n</code></pre>"},{"location":"processos/processos/#desvantagens_3","title":"Desvantagens","text":"<ul> <li> <p>a estrita altern\u00e2ncia n\u00e3o deve ser utilizada quando um processo \u00e9 muito mais lento do que outro.</p> </li> <li> <p>\u00c9 bem implementada em processos iguais</p> </li> <li> <p>Ela viola a regra de um processo fora da se\u00e7\u00e3o cr\u00edtica bloquear outro processo</p> </li> <li> <p>N\u00e3o \u00e9 uma solu\u00e7\u00e3o gen\u00e9rica</p> </li> </ul>"},{"location":"processos/processos/#algoritmo-de-peterson","title":"Algoritmo de Peterson","text":"<ul> <li> <p>Esse algoritmo minimizou o n\u00famero de loops e compara\u00e7\u00f5es necess\u00e1rias</p> </li> <li> <p>Garante a exclus\u00e3o m\u00fatua</p> </li> <li> <p>Os processos possuem um id \u00fanico (0 ou 1)</p> </li> <li> <p>O processo deve chamar uma fun\u00e7\u00e3o enter_region, que retorna s\u00f3 quando for seguro entrar na se\u00e7\u00e3o</p> </li> <li> <p>Ao terminar o processamento, a fun\u00e7\u00e3o leave_region deve ser chamada para indicar que outros processos podem prosseguir</p> </li> <li> <p>Isso garante que um processo fora da se\u00e7\u00e3o cr\u00edtica n\u00e3o bloqueie outros</p> </li> </ul>"}]}